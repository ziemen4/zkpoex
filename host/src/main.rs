// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
// zkVM: RISC-V ELF & image ID for proving and verification
use methods::{ZKPOEX_GUEST_ELF, ZKPOEX_GUEST_ID};

// zkVM core prover and receipt types
use risc0_zkvm::{default_prover, ExecutorEnv, Groth16Receipt, InnerReceipt, SuccinctReceipt};

// Environment utilities
use dotenv::dotenv;

// Utilities for working with U256 integers
use primitive_types::U256;

// Shared project modules
use shared::{
    evm_utils::get_blockchain_settings, 
    utils::{parse_cli_args_host, generate_function_signature}
};

// Serialization helpers
use serde::Serialize;

// Memory manipulation utility (byte slice conversion)
use bytemuck::cast_slice;

// File system access
use std::fs;
use std::fs::File;
use std::io::Write;

// Async runtime
use tokio;

// Dependancies for call_verify_function()
use alloy_provider::ProviderBuilder;
use alloy_signer_local::PrivateKeySigner;
use alloy_sol_types::{sol};
use anyhow::Context;
use hex::encode;
use std::env;
use url::Url;
use tracing_subscriber::EnvFilter;

use risc0_zkvm::sha::Digestible;
use anyhow::bail;

/// Encode the seal of the given receipt for use with EVM smart contract verifiers.
///
/// Appends the verifier selector, determined from the first 4 bytes of the verifier parameters
/// including the Groth16 verification key and the control IDs that commit to the RISC Zero
/// circuits.
pub fn encode_seal(receipt: &risc0_zkvm::Receipt) -> Result<Vec<u8>, anyhow::Error> {
    let seal = match receipt.inner.clone() {
        InnerReceipt::Fake(receipt) => {
            let seal = receipt.claim.digest().as_bytes().to_vec();
            let selector = &[0xFFu8; 4];
            // Create a new vector with the capacity to hold both selector and seal
            let mut selector_seal = Vec::with_capacity(selector.len() + seal.len());
            selector_seal.extend_from_slice(selector);
            selector_seal.extend_from_slice(&seal);
            selector_seal
        }
        InnerReceipt::Groth16(receipt) => {
            let selector = &receipt.verifier_parameters.as_bytes()[..4];
            // Create a new vector with the capacity to hold both selector and seal
            let mut selector_seal = Vec::with_capacity(selector.len() + receipt.seal.len());
            selector_seal.extend_from_slice(selector);
            selector_seal.extend_from_slice(receipt.seal.as_ref());
            selector_seal
        }
        _ => bail!("Unsupported receipt type"),
        // TODO(victor): Add set verifier seal here.
    };
    Ok(seal)
}

sol! {
    struct PublicInput {
        bool exploitFound;
        bytes32 programSpecHash;
        bytes32 contextStateHash;
        address proverAddress;
    }
}

/// -------------------------------------------
/// Calls the `verify()` function of the deployed VerifierContract
/// -------------------------------------------
pub async fn call_verify_function(
    private_key: &str,
    verifier_contract_address: &str,
    public_input: Vec<u8>,
    seal: Vec<u8>,
) -> anyhow::Result<()> {
    let rpc_url = env::var("ETH_RPC_URL").context("Impossible to find env var: RPC_URL")?;
    shared::log_debug!("RPC URL: {}", rpc_url);
    let url = Url::parse(&rpc_url)?;
    let pk: PrivateKeySigner = private_key.parse()?;
    let provider = ProviderBuilder::new().wallet(pk).on_http(url);

    sol!(
        #[sol(rpc)]
        VerifierContract,
        "../contracts/out/VerifierContract.sol/VerifierContract.json"
    );

    let verifier = VerifierContract::new(verifier_contract_address.parse()?, provider);
    let verify = verifier.verify(public_input.into(), seal.into());
    let calldata_hex = format!("0x{}", encode(&verify.calldata()));
    fs::write("calldata.txt", &calldata_hex)?;
    verify.call().await?;
    shared::log_debug!("Verify function called successfully");

    Ok(())
}

fn save_all_bytes(filename: &str, data: &[u8]) -> std::io::Result<()> {
    let mut file = File::create(filename)?;
    file.write_all(data)?;
    Ok(())
}

#[derive(Serialize, Debug)]
struct InputData<'a> {
    calldata: &'a str,
    context_state: String,
    program_spec: String,
    blockchain_settings: String,
    value: U256,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    dotenv().ok();

    // Parse CLI arguments
    let matches = parse_cli_args_host();

    let function_name = matches.get_one::<String>("function").unwrap();
    let params = matches.get_one::<String>("params").unwrap();
    let context_state_file = matches
        .get_one::<std::path::PathBuf>("context-state")
        .unwrap();
    let program_spec_file = matches
        .get_one::<std::path::PathBuf>("program-spec")
        .unwrap();
    let value_from_cli = matches.get_one::<String>("value").unwrap();
    let blockchain_settings = get_blockchain_settings().await?;
    let verbose = matches.get_flag("verbose");

    println!("Verbose: {}", verbose);
    let filter = if verbose {
        // debug for everything
        "debug"
    } else {
        // info+ for everything
        "info"
    };

    let env_filter = EnvFilter::new(filter);

    // Initialize the tracing subscriber with the environment filter
    tracing_subscriber::fmt()
        .with_env_filter(env_filter)
        .init();

    // Read the contract bytecode file and generate the calldata dynamically
    let calldata = generate_function_signature(function_name, &[params]);
    shared::log_debug!("Calldata: {}", calldata);

    // Read the context state and program specification files
    let context_state = fs::read_to_string(context_state_file)
        .map_err(|e| format!("Failed to read context state file: {}", e))?;
    shared::log_debug!("Context state: {:?}", context_state);
    
    let program_spec = fs::read_to_string(program_spec_file).expect("Failed to read file");
    shared::log_debug!("Program spec: {:?}", program_spec);

    let value = if value_from_cli.is_empty() {
        U256::from_dec_str("0").unwrap()
    } else {
        U256::from_dec_str(value_from_cli).unwrap()
    };
    
    // Construct the input data
    let input = InputData {
        calldata: &calldata,
        context_state,
        program_spec,
        blockchain_settings,
        value,
    };

    shared::log_debug!("Sending input to guest: {:?}", input);
    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    // let prove_info = prover.prove(env, ZKPOEX_GUEST_ELF).unwrap();
    let prove_info = prover
        .prove_with_ctx(
            env,
            &risc0_zkvm::VerifierContext::default(),
            ZKPOEX_GUEST_ELF,
            &risc0_zkvm::ProverOpts::groth16(),
        )
        .unwrap();

    shared::log_debug!("Length in bytes: {}", prove_info.receipt.journal.bytes.len());

    // extract the receipt.
    let receipt = prove_info.receipt;

    // Encode the seal with the selector.
    let onchain_seal = encode_seal(&receipt)?;

    let journal_bytes = receipt.journal.bytes.clone();
    shared::log_debug!("Journal bytes: {:?}", &journal_bytes);

    let seal_bytes: &[u8] = match &receipt.inner {
        InnerReceipt::Succinct(SuccinctReceipt { seal, .. }) => cast_slice(seal),
        InnerReceipt::Groth16(Groth16Receipt { seal, .. }) => cast_slice(seal),
        InnerReceipt::Composite { .. } => {
            shared::log_warn!("Warning: Full receipt does not contain succinct seal!");
            &[0u8; 32]
        }
        _ => {
            shared::log_warn!("Warning: Unknown receipt type!");
            &[0u8; 32]
        }
    };

    shared::log_debug!("Seal bytes: {:?}", &seal_bytes);

    // Save the journal and seal and provide after to VerifierContract.sol
    save_all_bytes("journal.bin", &journal_bytes)?;
    save_all_bytes("seal.bin", &seal_bytes)?;
    save_all_bytes("onchain_seal.bin", &onchain_seal)?;

    let output: u32 = receipt.journal.decode().unwrap();

    shared::log_info!(
        "Hello, world! I generated a proof of guest execution! {} is a public output from journal",
        output
    );

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    let verification = receipt.verify(ZKPOEX_GUEST_ID);
    shared::log_info!("Verification: {:?}", verification);

    match receipt.verify(ZKPOEX_GUEST_ID) {
        Ok(_) => shared::log_info!("Verification successful!"),
        Err(e) => shared::log_error!("Verification failed: {:?}", e),
    }
    Ok(())
}


#[cfg(test)]
mod tests {
    pub const VERIFIER_TESTNET_HOLESKY_ADDRESS: &str = "0xEF2E59fB6640d5dFDD0e8533B01220896CfBc706";
    use alloy_sol_types::SolType;
    use crate::{PublicInput, call_verify_function, encode};
    use tracing_subscriber::EnvFilter;
    
    #[tokio::test]
    async fn test_onchain_verify_basic_vuln() -> Result<(), Box<dyn std::error::Error>> {
        let filter = "info";
        let env_filter = EnvFilter::new(filter);
    
        // Initialize the tracing subscriber with the environment filter
        tracing_subscriber::fmt()
            .with_env_filter(env_filter)
            .init();

        dotenv::dotenv().ok();
        let private_key = std::env::var("WALLET_PRIV_KEY").expect("PRIVATE_KEY must be set in the .env file");

        let journal = std::fs::read("../sc-owner/src/test/journal.bin")?;
        let seal = std::fs::read("../sc-owner/src/test/onchain_seal.bin")?;

        shared::log_info!("Journal size: {}", journal.len());
        shared::log_info!("Seal size: {}", seal.len());
        shared::log_info!("Journal: {:?}", journal);
        shared::log_info!("Seal: {:?}", seal);

        // Print journal and seal as hex
        shared::log_info!("Journal hex: 0x{}", hex::encode(&journal));
        shared::log_info!("Seal hex: 0x{}", hex::encode(&seal));

        let input = <PublicInput as SolType>::abi_decode(&journal)
            .expect("Impossible to decode journal.bin");

        shared::log_info!("\n=====================");
        shared::log_info!("PUBLIC INPUT DECODED");
        shared::log_info!("=====================\n");

        shared::log_info!("Exploit found: {}", input.exploitFound);
        shared::log_info!(
            "Program spec hash: 0x{}",
            encode(input.programSpecHash)
        );
        shared::log_info!(
            "Context state hash: 0x{}",
            encode(input.contextStateHash)
        );
        shared::log_info!("Prover address: 0x{}", encode(input.proverAddress));

        let _output = call_verify_function(
            &private_key,
            VERIFIER_TESTNET_HOLESKY_ADDRESS,
            journal,
            seal,
        )
        .await?;

        shared::log_info!("✅ All tests passed! Valid proof verified on-chain.");

        Ok(())
    }
}

