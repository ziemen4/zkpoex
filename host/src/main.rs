// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{ZKPOEX_GUEST_ELF, ZKPOEX_GUEST_ID};

use bytemuck::cast_slice;
use dotenv::dotenv;
use primitive_types::U256;
use risc0_zkvm::{default_prover, ExecutorEnv, InnerReceipt, SuccinctReceipt};
use serde::Serialize;
use serde_json;
use shared::evm_utils;
use shared::input::AccountData;
use shared::utils;
use std::collections::BTreeMap;
use std::env;
use std::fs;
use std::fs::File;
use std::io::Write;
use tokio;

fn save_bytes32(filename: &str, data: &[u8]) -> std::io::Result<()> {
    let mut file = File::create(filename)?;
    if data.len() < 32 {
        let mut padded = vec![0u8; 32];
        padded[..data.len()].copy_from_slice(data);
        file.write_all(&padded)?;
    } else {
        file.write_all(&data[..32])?;
    }
    Ok(())
}

#[derive(Serialize, Debug)]
struct InputData<'a> {
    calldata: &'a str,
    context_state: Vec<AccountData>,
    program_spec: String,
    blockchain_settings: String,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    dotenv().ok();

    // Parse CLI arguments
    let matches = utils::parse_cli_args();

    let function_name = matches.get_one::<String>("function").unwrap();
    let params = matches.get_one::<String>("params").unwrap();
    let conditions = matches.get_one::<String>("conditions").unwrap();
    let context_state_file = matches
        .get_one::<std::path::PathBuf>("context-state")
        .unwrap();
    let abi_file = <std::path::PathBuf>::from(matches.get_one::<String>("abi").unwrap());
    let program_spec_file = matches
        .get_one::<std::path::PathBuf>("program-spec")
        .unwrap();
    let blockchain_settings = evm_utils::get_blockchain_settings().await?;

    // Read the contract bytecode file and generate the calldata dynamically
    let contract_bytecode_deployment =
        fs::read_to_string(contract_bytecode_file).expect("Failed to read contract bytecode file");
    let calldata = utils::generate_function_signature(function_name, &[params]);

    println!("Calldata: {}", calldata);

    // Read the context state and program specification files
    let context_state_json = fs::read_to_string(context_state_file).expect("Failed to read file");
    let context_state: Vec<AccountData> = serde_json::from_str(&context_state_json)?;

    let program_spec_json = fs::read_to_string(program_spec_file).expect("Failed to read file");
    let program_spec: BTreeMap<String, serde_json::Value> =
        serde_json::from_str(&program_spec_json)?;

    // Construct the input data
    let input = InputData {
        calldata: &calldata,
        context_state,
        program_spec,
        blockchain_settings,
    };

    println!("Sending input to guest: {:?}", input);

    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    let prove_info = prover.prove(env, ZKPOEX_GUEST_ELF).unwrap();

    // extract the receipt.
    let receipt = prove_info.receipt;

    let journal_bytes = receipt.journal.bytes.as_slice();
    let seal_bytes: &[u8] = match &receipt.inner {
        InnerReceipt::Succinct(SuccinctReceipt { seal, .. }) => cast_slice(seal),
        InnerReceipt::Composite { .. } => {
            eprintln!("Warning: Full receipt does not contain succinct seal!");
            &[0u8; 32]
        }
        _ => {
            eprintln!("Warning: Unknown receipt type!");
            &[0u8; 32]
        }
    };

    // Save the journal and seal and provide after to VerifierContract.sol
    save_bytes32("journal.bin", journal_bytes)?;
    save_bytes32("seal.bin", seal_bytes)?;

    let output: u32 = receipt.journal.decode().unwrap();

    println!(
        "Hello, world! I generated a proof of guest execution! {} is a public output from journal",
        output
    );

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    let verification = receipt.verify(ZKPOEX_GUEST_ID);
    println!("Verification: {:?}", verification);

    match receipt.verify(ZKPOEX_GUEST_ID) {
        Ok(_) => println!("Verification successful!"),
        Err(e) => println!("Verification failed: {:?}", e),
    }
    Ok(())
}
