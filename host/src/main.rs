// SPDX-License-Identifier: MIT

mod onchain_verifier;

// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
// zkVM: RISC-V ELF & image ID for proving and verification
use methods::ZKPOEX_GUEST_ELF;

// zkVM core prover and receipt types
use risc0_zkvm::{default_prover, ExecutorEnv, Groth16Receipt, InnerReceipt, SuccinctReceipt};

// Environment utilities
use dotenv::dotenv;

// Utilities for working with U256 integers
use primitive_types::U256;

// Shared project modules
use shared::{
    evm_utils::{encode_seal, get_blockchain_settings},
    utils::{generate_function_signature, parse_cli_args_host},
};

// Serialization helpers
use serde::Serialize;

// Memory manipulation utility (byte slice conversion)
use bytemuck::cast_slice;

// File system access
use bincode;
use std::fs;
use std::fs::File;
use std::io::Write;
use std::io::{self};

// Async runtime
use tokio;

use alloy::sol;
use anyhow::Context;
use tracing_subscriber::EnvFilter;

sol! {
    /// The VerifierContract interface
    interface VerifierContract {
        function verify(address beneficiary, bytes calldata seal, bytes calldata journal) public payable;
    }
}

fn save_receipt_binary(filename: &str, receipt: &risc0_zkvm::Receipt) -> std::io::Result<()> {
    let encoded = bincode::serialize(receipt).expect("Failed to serialize receipt");
    let mut file = File::create(filename)?;
    file.write_all(&encoded)?;
    Ok(())
}

#[derive(Serialize, Debug)]
struct InputData<'a> {
    calldata: &'a str,
    context_state: String,
    program_spec: String,
    blockchain_settings: String,
    value: U256,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    dotenv().ok();
    // Parse CLI arguments
    let matches = parse_cli_args_host();

    let function_name = matches.get_one::<String>("function").unwrap();
    let params = matches.get_one::<String>("params").unwrap();
    let context_state_file = matches
        .get_one::<std::path::PathBuf>("context-state")
        .unwrap();
    let program_spec_file = matches
        .get_one::<std::path::PathBuf>("program-spec")
        .unwrap();
    let value_from_cli = matches.get_one::<String>("value").unwrap();
    let verbose = matches.get_flag("verbose");

    println!("Verbose: {}", verbose);
    let filter = if verbose {
        // debug for everything
        "debug"
    } else {
        // info+ for everything
        "info"
    };

    let env_filter = EnvFilter::new(filter);

    // Initialize the tracing subscriber with the environment filter
    tracing_subscriber::fmt().with_env_filter(env_filter).init();

    // Get blockchain settings
    let blockchain_settings = get_blockchain_settings().await?;

    // Read the contract bytecode file and generate the calldata dynamically
    let calldata = generate_function_signature(function_name, &[params]);
    shared::log_debug!("Calldata: {}", calldata);

    // Read the context state and program specification files
    let context_state = fs::read_to_string(context_state_file)
        .map_err(|e| format!("Failed to read context state file: {}", e))?;
    shared::log_debug!("Context state: {:?}", context_state);

    let program_spec = fs::read_to_string(program_spec_file).expect("Failed to read file");
    shared::log_debug!("Program spec: {:?}", program_spec);

    let value = if value_from_cli.is_empty() {
        U256::from_dec_str("0").unwrap()
    } else {
        U256::from_dec_str(value_from_cli).unwrap()
    };

    // Construct the input data
    let input = InputData {
        calldata: &calldata,
        context_state,
        program_spec,
        blockchain_settings,
        value,
    };

    shared::log_debug!("Sending input to guest: {:?}", input);
    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    // let prove_info = prover.prove(env, ZKPOEX_GUEST_ELF).unwrap();
    let prove_info = prover
        .prove_with_ctx(
            env,
            &risc0_zkvm::VerifierContext::default(),
            ZKPOEX_GUEST_ELF,
            &risc0_zkvm::ProverOpts::groth16(),
        )
        .unwrap();

    shared::log_debug!(
        "Length in bytes: {}",
        prove_info.receipt.journal.bytes.len()
    );

    // extract the receipt.
    let receipt = prove_info.receipt;

    let journal_bytes = receipt.journal.bytes.clone();
    shared::log_debug!("Journal bytes: {:?}", &journal_bytes);

    let seal_bytes: &[u8] = match &receipt.inner {
        InnerReceipt::Succinct(SuccinctReceipt { seal, .. }) => cast_slice(seal),
        InnerReceipt::Groth16(Groth16Receipt { seal, .. }) => cast_slice(seal),
        InnerReceipt::Composite { .. } => {
            shared::log_warn!("Warning: Full receipt does not contain succinct seal!");
            &[0u8; 32]
        }
        _ => {
            shared::log_warn!("Warning: Unknown receipt type!");
            &[0u8; 32]
        }
    };

    shared::log_debug!("Seal bytes: {:?}", &seal_bytes);

    // Save the receipt to a binary file
    save_receipt_binary("receipt.bin", &receipt)?;
    shared::log_info!("Receipt saved to receipt.bin");

    let output: u32 = receipt.journal.decode().unwrap();

    shared::log_info!(
        "Hello, world! I generated a proof of guest execution! {} is a public output from journal",
        output
    );


    println!("\nDo you want to verify the proof on-chain? [y/n]:");
    io::stdout().flush().unwrap();
    let mut output = String::new();
    io::stdin()
        .read_line(&mut output)
        .expect("Failed to read from input");
    if output.trim().to_lowercase() != "y" {
        shared::log_info!("Skipping onchain verification");
        return Ok(());
    }

    shared::log_info!("Starting onchain verification");
    /* ------ Onchain verification ------- */
    let private_key_str =
        std::env::var("WALLET_PRIV_KEY").expect("PRIVATE_KEY must be set in the .env file");
    let eth_rpc_url_str =
        std::env::var("ETH_RPC_URL").expect("ETHEREUM_RPC_URL must be set in the .env file");

    shared::log_info!("Ethereum RPC URL: {}", eth_rpc_url_str);
    shared::log_info!("Private key: {}", private_key_str);

    // Get Verifier Contract Address from stdin
    println!(
        "Please enter the Verifier Contract Address (starting with 0x) for the current network:"
    );
    io::stdout().flush().unwrap();

    let mut contract_address_str = String::new();
    io::stdin()
        .read_line(&mut contract_address_str)
        .expect("Failed to read contract address from input");

    // Extract the journal from the receipt.
    let onchain_journal = receipt.journal.bytes.clone();

    // Encode the seal with the selector.
    let onchain_seal = encode_seal(&receipt)?;

    onchain_verifier::verify_onchain(
        &private_key_str,
        &eth_rpc_url_str,
        &contract_address_str,
        onchain_seal,
        onchain_journal,
    )
    .await
    .context("Failed to verify on-chain")?;

    Ok(())
}
