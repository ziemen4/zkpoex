use std::collections::BTreeMap;

// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{
    ZKPOEX_GUEST_ELF, ZKPOEX_GUEST_ID
};
use primitive_types::U256;
use risc0_zkvm::{default_prover, ExecutorEnv};
use serde::Serialize;
use evm_runner::conditions::{Condition, FixedCondition, Operator};
use evm_runner::input::AccountData;

// TODO: Add custom serializer.
#[derive(Serialize, Debug)]
struct InputData<'a> {
    calldata: &'a str,
    caller_data: AccountData,
    target_data: AccountData,
    context_data: String,
    program_spec: String,
    blockchain_settings: String,
    public_key: String,
    missing_spec: Option<String>,
}

pub const TARGET_CONTRACT_EVM_PROGRAM: &str = include_str!("../../bytecode/TargetContract.bin-runtime");

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // An executor environment describes the configurations for the zkVM
    // including program inputs.
    // A default ExecutorEnv can be created like so:
    // `let env = ExecutorEnv::builder().build().unwrap();`
    // However, this `env` does not have any inputs.
    //
    // To add guest input to the executor environment, use
    // ExecutorEnvBuilder::write().
    // To access this method, you'll need to use ExecutorEnv::builder(), which
    // creates an ExecutorEnvBuilder. When you're done adding input, call
    // ExecutorEnvBuilder::build().

    // For example:
    let chain_id = "1";
    let calldata = "16112c6c0000000000000000000000000000000000000000000000000000000000000001"; // exploit(true)
    let blockchain_settings = format!(r#"
    {{
        "gas_price": "0",
        "origin": "0x0000000000000000000000000000000000000000",
        "block_hashes": "[]",
        "block_number": "0",
        "block_coinbase": "0x0000000000000000000000000000000000000000",
        "block_timestamp": "0",
        "block_difficulty": "0",
        "block_gas_limit": "0",
        "chain_id": "{}",
        "block_base_fee_per_gas": "0"
    }}
    "#, chain_id);

    let target_storage = BTreeMap::new();
    // Insert random storage values for the target contract.
    //target_storage.insert(
    //    H256::from_str("59f33fb19503abee8dd9fbdecc425b879c685af6fb88b6d51e5f57aaa9e8a607").unwrap(),
    //    H256::from_str("9dacead86f17b925da5cddb505562dc97c4ff6cad92157aa7ff2f2f7bd76e2b8").unwrap(),
    //);

    let target_data = AccountData {
        address: "4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97".to_string(),
        nonce: U256::one(),
        balance: U256::from_dec_str("1000000000000000000").unwrap(),
        storage: target_storage,
        code: hex::decode(TARGET_CONTRACT_EVM_PROGRAM).unwrap(),
    };
    let caller_data = AccountData {
        address: "E94f1fa4F27D9d288FFeA234bB62E1fBC086CA0c".to_string(),
        nonce: U256::one(),
        balance: U256::from_dec_str("10000000000000000000").unwrap(),
        storage: BTreeMap::new(),
        code: vec![],
    };

    let program_spec = vec![
        // Program specification is a list of (condition, method) pairs
        // Where method is defined by its method id
        // and condition is a list of conditions that must be satisfied for the method to be executed
        (
            Condition::Fixed(
                FixedCondition {
                    k_s: "4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97.balance".to_string(),
                    op: Operator::Gt,
                    v: U256::from_dec_str("0").unwrap(),
                }
            ),
            "16112c6c".to_string()
        )
    ];
    let seed: [u8; 32] = [42; 32]; // Deterministic seed
    let (_, public_key) = evm_runner::generate_keypair(&seed);
    let context_data: Vec<AccountData> = vec![];
    let input = InputData {
        calldata,
        caller_data,
        target_data,
        context_data: serde_json::to_string(&context_data).unwrap(),
        program_spec: serde_json::to_string(&program_spec).unwrap(),
        blockchain_settings,
        public_key,
        missing_spec: None,
    };

    println!("Sending input to guest: {:?}", input);

    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    let prove_info = prover
        .prove(env, ZKPOEX_GUEST_ELF)
        .unwrap();

    // extract the receipt.
    let receipt = prove_info.receipt;

    // TODO: Implement code for retrieving receipt journal here.

    // For example:
    let output: u32 = receipt.journal.decode().unwrap();

    println!("Hello, world! I generated a proof of guest execution! {} is a public output from journal", output);

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    receipt
        .verify(ZKPOEX_GUEST_ID)
        .unwrap();
}
