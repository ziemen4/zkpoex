use std::collections::BTreeMap;
mod utils;
// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use evm_runner::conditions::{Condition, FixedCondition, Operator};
use evm_runner::input::AccountData;
use methods::{ZKPOEX_GUEST_ELF, ZKPOEX_GUEST_ID};
use primitive_types::U256;
use risc0_zkvm::{default_prover, ExecutorEnv};
use serde::Serialize;
use std::fs;
use std::path::PathBuf;


#[derive(Serialize, Debug)]
struct InputData<'a> {
    calldata: &'a str,
    context_state: Vec<AccountData>,
    program_spec: String,
    blockchain_settings: String,
}

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // An executor environment describes the configurations for the zkVM
    // including program inputs.
    // A default ExecutorEnv can be created like so:
    // `let env = ExecutorEnv::builder().build().unwrap();`
    // However, this `env` does not have any inputs.
    //
    // To add guest input to the executor environment, use
    // ExecutorEnvBuilder::write().
    // To access this method, you'll need to use ExecutorEnv::builder(), which
    // creates an ExecutorEnvBuilder. When you're done adding input, call
    // ExecutorEnvBuilder::build().
    
    // For example:
    let chain_id = "1";
    let blockchain_settings = format!(
        r#"
    {{
        "gas_price": "0",
        "origin": "0x0000000000000000000000000000000000000000",
        "block_hashes": "[]",
        "block_number": "0",
        "block_coinbase": "0x0000000000000000000000000000000000000000",
        "block_timestamp": "0",
        "block_difficulty": "0",
        "block_gas_limit": "0",
        "chain_id": "{}",
        "block_base_fee_per_gas": "0"
    }}
    "#,
        chain_id
    );

    // Parse CLI arguments
    let matches = utils::parse_cli_args();

    let function_name = matches.get_one::<String>("function").unwrap();
    let params = matches.get_one::<String>("params").unwrap();
    let conditions = matches.get_one::<String>("conditions").unwrap();
    let contract_bytecode_file = matches.get_one::<std::path::PathBuf>("contract-bytecode").unwrap();

    // Read the contract bytecode file --> Generate the calldata dynamically
    let contract_bytecode = fs::read_to_string(contract_bytecode_file).expect("Failed to read contract bytecode file");
    let calldata = utils::generate_function_signature(function_name, &[params]);

    let target_storage = BTreeMap::new();
    let target_data = AccountData {
        address: "4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97".to_string(),
        nonce: U256::one(),
        balance: U256::from_dec_str("1000000000000000000").unwrap(),
        storage: target_storage,
        code: hex::decode(contract_bytecode.trim()).unwrap(),
    };
    let caller_data = AccountData {
        address: "E94f1fa4F27D9d288FFeA234bB62E1fBC086CA0c".to_string(),
        nonce: U256::one(),
        balance: U256::from_dec_str("10000000000000000000").unwrap(),
        storage: BTreeMap::new(),
        code: vec![],
    };
    let custom_data: Vec<AccountData> = vec![];

    // context_state is a vector of target_data, caller_data and flattened custom_data
    let context_state = {
        let mut v = vec![target_data, caller_data];
        v.extend(custom_data);
        v
    };

    // Set Dynamic Program Specification from utils::parse_conditions()
    // ----------------------------------------------------------------

    let program_spec = vec![
        // Program specification is a list of (condition, method) pairs
        // Where method is defined by its method id
        // and condition is a list of conditions that must be satisfied for the method to be executed
        (
            Condition::Fixed(FixedCondition {
                k_s: "4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97.balance".to_string(),
                op: Operator::Gt,
                v: U256::from_dec_str("0").unwrap(),
            }),
            calldata[..8].to_string(),
        ),
    ];

    // ----------------------------------------------------------------

    let input = InputData {
        calldata: &calldata,
        context_state,
        program_spec: serde_json::to_string(&program_spec).unwrap(),
        blockchain_settings,
    };

    println!("Sending input to guest: {:?}", input);

    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();
    
    // Obtain the default prover.
    let prover = default_prover();

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    let prove_info = prover.prove(env, ZKPOEX_GUEST_ELF).unwrap();

    // extract the receipt.
    let receipt = prove_info.receipt;

    // TODO: Implement code for retrieving receipt journal here.

    // For example:
    let output: u32 = receipt.journal.decode().unwrap();

    println!(
        "Hello, world! I generated a proof of guest execution! {} is a public output from journal",
        output
    );

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    let verification = receipt.verify(ZKPOEX_GUEST_ID);
    println!("Verification: {:?}", verification);

    match receipt.verify(ZKPOEX_GUEST_ID) {
        Ok(_) => println!("Verification successful!"),
        Err(e) => println!("Verification failed: {:?}", e),
    }   
}